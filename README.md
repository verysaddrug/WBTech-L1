
# Practic

[1. Дана структура Human (с произвольным набором полей и методов). Реализовать встраивание методов в структуре Action от родительской структуры Human (аналог наследования). ](https://github.com/verysaddrug/WBTech-L1/blob/main/task1.go)

[2. Написать программу, которая конкурентно рассчитает значение квадратов чисел взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout. ](https://github.com/verysaddrug/WBTech-L1/blob/main/task02.go)

[3. Дана последовательность чисел: 2,4,6,8,10. Найти сумму их квадратов(22+32+42….) с использованием конкурентных вычислений.](https://github.com/verysaddrug/WBTech-L1/blob/main/task03.go)

[4. Реализовать постоянную запись данных в канал (главный поток). Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout. Необходима возможность выбора количества воркеров при старте.  Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров. ](https://github.com/verysaddrug/WBTech-L1/blob/main/task04.go)

[5.   Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала — читать. По истечению N секунд программа должна завершаться.](https://github.com/verysaddrug/WBTech-L1/blob/main/task05.go)

[6.Реализовать все возможные способы остановки выполнения горутины.  ](https://github.com/verysaddrug/WBTech-L1/blob/main/task06.go)

[7. Реализовать конкурентную запись данных в map. ](https://github.com/verysaddrug/WBTech-L1/blob/main/task07.go)

[8. Дана переменная int64. Разработать программу которая устанавливает i-й бит в 1 или 0.](https://github.com/verysaddrug/WBTech-L1/blob/main/task08.go)
[9. Дана последовательность температурных колебаний: -25.4, -27.0 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить данные значения в группы с шагом в 10 градусов. Последовательность в подмножноствах не важна. ](https://github.com/verysaddrug/WBTech-L1/blob/main/task09.go)

[10. Дана последовательность температурных колебаний: -25.4, -27.0 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить данные значения в группы с шагом в 10 градусов. Последовательность в подмножноствах не важна.](https://github.com/verysaddrug/WBTech-L1/blob/main/task10.go)

# Theory
1. Какой самый эффективный способ конкатенации строк?

`Builder` использует внутренний буфер для сбора данных строки, который позволяет минимизировать количество аллокаций памяти и операций копирования, что делает его идеальным для сценариев, где требуется много операций конкатенации.

```go
var builder strings.Builder 
builder.WriteString("Hello, ")  
builder.WriteString("world!")  
result := builder.String()  
fmt.Println(result)
```

---

2. Что такое интерфейсы, как они применяются в Go? 

Интерфейс - контракт который мы должны реализовать

Интерфейсы в языке программирования Go описывают абстрактный набор методов, которые должен реализовать конкретный тип данных для соответствия интерфейсу. Это позволяет разработчикам абстрагироваться от конкретных реализаций и сосредоточиться на общей функциональности, которую могут предоставить объекты.

 Основные особенности интерфейсов в Go:
> - **Абстракция поведения**: Интерфейсы определяют только ожидаемое поведение (методы) от типов данных, без реализации. Это способствует созданию гибкого и масштабируемого кода.
> 
> - **Неявная реализация**: В Go не требуется явно указывать, что тип реализует интерфейс. Если тип обладает всеми методами, указанными в интерфейсе, он автоматически считается его реализующим.
> - **Структурная типизация**: Совместимость типов с интерфейсами определяется не по имени типа, а по структуре (методам). Это значит, что два разных типа, имеющие одинаковые наборы методов, могут быть совместимы с одним и тем же интерфейсом.

---

3. Чем отличаются RWMutex от Mutex? 

 В Go, `sync.Mutex` и `sync.RWMutex` оба служат для обеспечения безопасного доступа к данным в условиях многопоточности, но они предназначены для разных сценариев использования и работают немного по-разному.

 Mutex (`sync.Mutex`)

 `Mutex` — это взаимоисключающая блокировка, предназначенная для обеспечения, что только один горутин может получить доступ к определенной части кода за один раз. Это предотвращает одновременное изменение данных разными горутинами, что может привести к состоянию гонки или другим ошибкам согласованности данных.

 RWMutex (`sync.RWMutex`)

`RWMutex`, или блокировка для чтения/записи, предоставляет большую гибкость, чем стандартный `Mutex`, позволяя множеству горутин читать данные одновременно, но только одному горутину - изменять данные в любой момент времени. Это делает `RWMutex` особенно полезным в сценариях, где операции чтения данных происходят гораздо чаще, чем операции записи.

`RWMutex` имеет два типа блокировок:

- **Read Lock (`RLock`)**: позволяет множественным горутинам получить блокировку для операций чтения.
- **Write Lock (`Lock`)**: работает как обычный `Mutex`, блокируя доступ для всех других горутин, включая читателей и писателей.

 Отличия:
> - **Гибкость в использовании**: `RWMutex` предлагает отдельные блокировки для операций чтения и записи, позволяя параллельное чтение, что может значительно увеличить производительность в чтение-интенсивных приложениях. `Mutex` же блокирует доступ для всех операций при взятии блокировки.
> - **Выбор сценария использования**: Если в приложении операции чтения данных происходят чаще, чем операции записи, использование `RWMutex` может быть более предпочтительным. Для сценариев, где операции записи происходят так же часто, как и операции чтения, или где нет четкой разницы в частоте операций, `Mutex` может быть достаточен.

---

4. Чем отличаются буферизированные и не буферизированные каналы?  

В Go каналы используются для обмена данными между горутинами, при этом механизм каналов поддерживает как синхронные, так и асинхронные паттерны взаимодействия. Различие между буферизированными и не буферизированными каналами касается того, как данные передаются через канал и как канал управляет доступом к этим данным.

Не буферизированные каналы: `ch := make(chan int`) 
Не буферизированный канал не имеет внутреннего хранилища, или его буфер равен нулю. Это значит, что отправка в не буферизированный канал блокируется, пока другая горутина не выполнит операцию приёма из этого канала. Аналогично, операция приёма блокируется, пока другая горутина не отправит данные в канал. Таким образом, каждая операция отправки требует соответствующей операции приема, и наоборот. Не буферизированный канал гарантирует синхронизацию между горутинами — отправитель и получатель синхронизируются при каждой операции передачи.

Буферизированные каналы: `ch := make(chan int, 2)`
Буферизированный канал имеет внутренний буфер определенного размера. Отправка в буферизированный канал блокируется, только когда буфер заполнен. Аналогично, операция приема из буферизированного канала блокируется, только если буфер пуст. Буферизированный канал позволяет отправителю отправлять множество элементов до блокировки на основе количества уже хранящихся элементов, и получателю — получать эти элементы без необходимости для отправителя быть готовым отправить их в тот же момент.


Отличия:
> 1. **Блокировка поведения**: Не буферизированные каналы блокируются на каждой операции отправки, пока соответствующий  принимающий канал не получит данные, и наоборот. Буферизированные каналы блокируются только при попытке отправить данные в полный канал или прочитать из пустого.
>   
> 2. **Производительность и скорость**: Буферизированные каналы могут улучшить производительность, так как они позволяют избежать блокировок, если продюсеры не превышают емкость канала. Они подходят для ситуаций, где горутины производят данные быстрее или медленнее, чем они потребляются.
>    
> 3. **Использование**: Не буферизированные каналы идеальны для ситуаций, когда требуется строгая синхронизация или передача управления между горутинами. Буферизированные каналы лучше подходят для сценариев, где нужно сглаживание или временное накопление потока данных.

В выборе между буферизированными и не буферизированными каналами следует учитывать требуемую степень синхронизации между горутинами и возможные производственные нагрузки на  приложение.

---

5. Какой размер у структуры struct{}{}?
Struct{}{} - или пустая структура в Go ничего не весит - 0 байт
Пустые структуры обычно используются в качестве типа для каналов или мьютексов,
когда необходимо уведомить другие горутины без передачи каких-либо фактических данных. Так же может использоваться для создания множества с помощью `map`
`sets := make(map[string]struct{})`

---

6. Есть ли в Go перегрузка методов или операторов?  

В Go перегрузка функций не поддерживается напрямую, иначе говоря, нельзя создать несколько функций с одинаковыми именами, но разными параметрами.

  
```go
package main

import "fmt"

type Rectangle struct {
    width, height float64
}

type Circle struct {
    radius float64
}

func (r Rectangle) area() float64 {
    return r.width * r.height
}

func (c Circle) area() float64 {
    return 3.14 * c.radius * c.radius
}

func main() {
    r := Rectangle{width: 5, height: 3}
    c := Circle{radius: 2.5}

    fmt.Println("Rectangle area:", r.area())
    fmt.Println("Circle area:", c.area())
}
```

---

7. В какой последовательности будут выведены элементы map[int]int?
```go
m[0]=1
m[1]=124
m[2]=281
```

В случайной. Порядок вывода при итерации по мапе не гарантирован.

---

8. В чем разница make и new?
`new`:
> - `new` используется для выделения памяти для нового значения указанного типа и возвращает указатель на это значение.
> - Он принимает аргументом тип данных и возвращает указатель на нулевое значение этого типа.
> - Преимущественно используется для выделения памяти под структуры или указатели на другие типы.

```go
package main

import "fmt"

func main() {
    // Создаем указатель на int
    ptr := new(int)
    fmt.Println(*ptr) // Вывод: 0 (нулевое значение для int)
}

```

`make`:
> - `make` используется для создания и инициализации слайсов, мап и каналов в Go.
> - Он принимает тип данных, который не является указателем, а также дополнительные аргументы, если это необходимо для инициализации объекта (например, емкость для слайса).
> - Возвращает инициализированный объект указанного типа.

```go
package main

import "fmt"

func main() {
    // Создаем слайс типа int с длиной 5 и емкостью 10
    slice := make([]int, 5, 10)
    fmt.Println(len(slice)) // Вывод: 5
    fmt.Println(cap(slice)) // Вывод: 10
}
```

Таким образом, основная разница между `make` и `new` заключается в их предназначении: `new` используется для выделения памяти и возвращения указателя на ноль, а `make` используется для инициализации встроенных типов данных (слайсов, мап и каналов) и возвращает готовый к использованию объект.

---

9. Сколько существует способов задать переменную типа slice или map? 
```go
// slice - 6
letters := []string{}
letters := []string{"a", "b", "c", "d"}
var letters []string
letters := make([]string, 0)
letters := make([]string, 0, 10)
letters := new([]string)

// map - 5
var m map[string]string
m := map[string]string{
    "123": "456",
    "test": "hello",
}
m := make(map[string]string)
m := make(map[string]string, 10)
m := new(map[string]string)
```

---

10. Что выведет данная программа и почему?
```go
func update(p *int) {

  b := 2

  p = &b

}

  

func main() {

  var (

     a = 1

     p = &a

  )

  fmt.Println(*p)

  update(p)

  fmt.Println(*p)

}
```

```
1
1
```

- В функции main, создается переменная a со значением 1, и затем переменной p присваивается адрес этой переменной a.
- Затем в fmt.Println(*p) происходит вывод значения, на которое указывает указатель p. Это значение равно 1.
- Далее вызывается функция update(p). В этой функции создается переменная b со значением 2, и указатель p меняет свое значение на адрес переменной b. Однако, это изменение происходит внутри функции,
  и оно не влияет на значение указателя p в функции main.
- После возврата из функции update, в fmt.Println(*p) снова происходит вывод значения,
  на которое указывает указатель p, и оно по-прежнему равно 1.

Функция update изменяет только копию указателя p, которая была передана в нее,
и эти изменения не влияют на значение указателя p в функции main.

---

11. Что выведет данная программа и почему?

```go
func main() {  
    wg := sync.WaitGroup{}  
    for i := 0; i < 5; i++ {  
       wg.Add(1)  
       go func(wg sync.WaitGroup, i int) {  
          fmt.Println(i)  
          wg.Done()  
       }(wg, i)  
    }  
    wg.Wait()  
    fmt.Println("exit")  
}
```

```
0
1
2
3
4
fatal error: all goroutines are asleep - deadlock!
```

 - Данный код создает анонимную горутину, в которой принимаются параметры wg и i.
 - Внутри анонимной горутины выводится значение i, и затем вызывается wg.Done().    Однако wg передается по значению, поэтому вызов wg.Done() уменьшает копию WaitGroup, а не оригинальный WaitGroup, созданный в main().
 - После каждого вызова go func, создается новая анонимная горутина, которая работает асинхронно.

После того как создаются все анонимные горутины, главная горутина достигает wg.Wait(), ожидая, что все анонимные горутины закончат свою работу и вызовут wg.Done(). Однако, так как каждая анонимная горутина уменьшает копию WaitGroup, а не оригинальный WaitGroup, счетчик остается ненулевым.

Это приводит к deadlock (зависанию), потому что wg.Wait() ожидает, что счетчик станет нулевым, но этого не происходит из-за неверного использования WaitGroup.  

Чтобы исправить это, нужно передать WaitGroup и i по указателю в анонимную горутину, чтобы изменения в анонимных горутинах влияли на оригинальные переменные.
```go 
func main() {  
    wg := sync.WaitGroup{}  
    for i := 0; i < 5; i++ {  
       wg.Add(1)  
       go func(wg *sync.WaitGroup, i int) {  
          fmt.Println(i)  
          wg.Done()  
       }(&wg, i)  
    }  
    wg.Wait()  
    fmt.Println("exit")  
}
```

```
4
3
1
0
2
exit
```

---

12. Что выведет данная программа и почему?
```go
func main() {  
    n := 0  
    if true {  
       n := 1  
       n++  
    }  
    fmt.Println(n)  
}
```

```
0
```

Программа выведет 0. Конструкция if создает новую область видимости, переменная n создается в ней и инкрементируется. При этом переменная n конструкции if не затрагивается, так как она находится в другой области видимости.

---

13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {  
    v[0] = 100  
    v = append(v, b)  
}  
  
func main() {  
    var a = []int8{1, 2, 3, 4, 5}  
    someAction(a, 6)  
    fmt.Println(a)  
}
```

```
[100 2 3 4 5]
```

 В функции main создается слайс a с элементами `[1, 2, 3, 4, 5]` 
 Вызывается функция someAction(a, 6), в которой передается слайс a и число 6.
 
 Внутри функции someAction выполняется следующее:
  - Элементу с индексом 0 слайса v (который на самом деле указывает на тот же слайс a присваивается значение 100,  изменяя исходный слайс a.
  - Затем вызывается append(v, b), где v все еще указывает на тот же слайс a, но функция append создает новый слайс на основе v и добавляет элемент b (который равен (6) в конец этого нового слайса. Однако, этот новый слайс не влияет на оригинальный a
  
   После возврата из функции someAction, в функции main выводится содержимое слайса a,    и он остается `[100, 2, 3, 4, 5]`, потому что изменение элемента внутри    функции someAction остается влияющим на оригинальный слайс a

---
   
14. Что выведет данная программа и почему?

```go
func main() {  
    slice := []string{"a", "a"}  
  
    func(slice []string) {  
       slice = append(slice, "a")  
       slice[0] = "b"  
       slice[1] = "b"  
       fmt.Print(slice)  
    }(slice)  
    fmt.Print(slice)  
}
```

```
[b b a][a a]
```

В данной программе анонимной функции передается через параметры слайс, то есть он копируется. Меняя этот слайс мы не меняем слайс в главной функции

Внутри функции main создаётся слайс slice с элементами "a" и "a"
Затем вызывается анонимная функция и передается в нее копия слайса slice.
Внутри этой анонимной функции происходит следующее:     
- Вызывается append(slice, "a") поэтому к копии слайса добавляется значение a,        на этот момент слайс имеет значения - "a", "a" и "a"
- Первые два элемента копированного слайса изменяются на "b"
- Выводится содержимое измененного слайса, то есть `["b", "b", "a"]`
После завершения анонимной функции, выводится содержимое исходного слайса slice,    который остается без изменений и равен `["a", "a"]`

