package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

/*
   Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде.
   По завершению программа должна выводить итоговое значение счетчика.
*/

// Counter - структура, предназначенная для безопасного инкрементирования в многопоточной среде.
type counter struct {
	count int64 // используем int64 для хранения значения счетчика, поддерживаемого атомарными операциями
}

// increment увеличивает счетчик на 1 с использованием атомарной операции для безопасности в конкурентной среде.
func (c *counter) increment() {
	atomic.AddInt64(&c.count, 1)
}

// getCount возвращает текущее значение счетчика, используя атомарную операцию для безопасного чтения.
func (c *counter) getCount() int64 {
	return atomic.LoadInt64(&c.count)
}

// task18 запускает функцию, которая демонстрирует безопасное использование счетчика в многопоточной среде.
func task18() {
	fmt.Printf("\n ============ Task 18: ============ \n\n")

	var count counter // создаем экземпляр счетчика

	var wg sync.WaitGroup     // используем WaitGroup для ожидания завершения всех горутин
	for i := 0; i < 50; i++ { // запускаем 50 горутин для инкрементирования счетчика
		wg.Add(1) // добавляем счетчик горутин к WaitGroup
		go func() {
			defer wg.Done()   // уменьшаем счетчик WaitGroup по завершении горутины
			count.increment() // инкрементируем счетчик
		}()
	}

	wg.Wait() // ожидаем завершения всех горутин

	fmt.Printf(" Count: %d \n", count.getCount()) // выводим итоговое значение счетчика

	fmt.Printf("\n ================================= \n\n")
}
