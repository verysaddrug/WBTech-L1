package main

import "fmt"

/*
   Реализовать быструю сортировку массива (quicksort) встроенными методами языка.


0. Если размер массива больше 1, то начинаем/продолжаем сотировку
1. Определение опорного элемента (в данной вариации - последний элемент) массива
2. Проход по массиву с двумя индексами: i, j
3. Если текущий элемент с индексом j меньше опорного элемента, то меняем элементы
	с индексами i, j местами, i увеличивается на единицу
4. j увеличивается на единицу
5. Когда j дошел до конца массива, меняем местами опорный элемент и элемент с индексом i,
	при этом он встает на свое место, то есть все элементы левее - меньше, а правее - больше
6. Подаем рекурсивно на сортировку левую и правую части массива, при этом
	опорный элемент не включается ни в одну из них

Отдельно отмечу, что квиксорт можно распараллелить, но тогда придется выделять больше памяти,
поскольку либо каждый поток будет работать с отдельным подмассивом, либо придется использовать
мьютексы, а тогда в этом не будет смысла. Но в тз не было сказано ни про параллельность, ни про
предпочтения по оптимизации с точки зрения памяти/скорости/производительности.

*/

func quickSort(sl []int, low, high int) {
	if low < high { // продолжаем пока левая граница не равна правой

		//Подаем рекурсивно на сортировку левую и правую части массива, при этом
		//	опорный элемент не включается ни в одну из них
		pi := partition(sl, low, high)
		quickSort(sl, low, pi-1)
		quickSort(sl, pi+1, high)
	}
}

func partition(sl []int, low, high int) int {
	pivot := sl[high] // Определение опорного элемента (в данной вариации - последний элемент) массива
	i := low - 1
	//Проход по массиву с двумя индексами: i, j
	for j := low; j < high; j++ {
		if sl[j] < pivot { // Если текущий элемент с индексом j меньше опорного элемента, то меняем элементы
			// с индексами i, j местами, i увеличивается на единицу
			i++
			sl[i], sl[j] = sl[j], sl[i]
		}
	}
	//Когда j дошел до конца массива, меняем местами опорный элемент и элемент с индексом i,
	//	при этом он встает на свое место, то есть все элементы левее - меньше, а правее - больше
	sl[i+1], sl[high] = sl[high], sl[i+1]
	return i + 1
}

func task16() {
	fmt.Printf("\n ============ Task 16: ============ \n\n")

	sl := []int{9, 8, 7, 6, 5, 1, 2, 4, 3}
	fmt.Println("Слайс до сортировки:", sl)

	quickSort(sl, 0, len(sl)-1)
	fmt.Println("Слайс после сортировки:", sl)

	fmt.Printf("\n ================================= \n\n")
}
